[ { "title": "凪葵 - 空が凪いだら(고요한 뒤에) 가사", "url": "/posts/%E5%87%AA%E8%91%B5-%E7%A9%BA%E3%81%8C%E5%87%AA%E3%81%84%E3%81%A0%E3%82%89(%EA%B3%A0%EC%9A%94%ED%95%9C-%EB%92%A4%EC%97%90)/", "categories": "translate, music", "tags": "translate, music, lyrics, 凪葵", "date": "2024-08-06 23:17:57 +0900", "snippet": "空っぽな今日からきっと逃れたくて카랏포나 쿄오카라 킷토 노가레타쿠테텅 빈 오늘로부터 분명 벗어나고 싶어서目指した雲메자시타 쿠모목표로 한 구름がらんどうな僕はみっともないな가란도오나 보쿠와 밋토모나이나텅 빈 나는 보기 흉하네きっと誓うよ空に킷토 치카우요 소라니반드시 맹세할게 하늘에もう怖くないこと모오 코와쿠 나이 코토더 이상 무섭지 않다고不安そうに笑った表情で手を伸ばした후안소오니 와랏타 효오조오데 테오 노바시타불안한 듯 웃는 표정으로 손을 뻗었어空に頼るように소라니 타요루요오니하늘에 의지하듯이フラットな声に乗せた후랏토나 코에니 노세타플랫한 목소리에 태워서届かないね토도카나이네닿지 않네わかってるって와캇테룻테알고 있다고踏み出して見えた景色が過去の僕を笑った후미다시테 미에타 케시키가 카코노 보쿠오 와랏타발을 내디뎌 보인 풍경이 과거의 나를 비웃었어放った「忘れたくて」하낫타 「와스레타쿠테 」떠나보낸 「잊고싶어서 」怖がって足踏みでも確かにそこに見たんだ코와 갓테 아시부미 데모 타시카니 소코니 미타다겁먹은 채 제자리걸음 하지만 분명히 거기서 봤어白んだ空시란다 소라하얗게 밝아오는 하늘音まで不確か오토마데 후타시카소리마저 불확실해眺めてたら降り注いだ나가메테타라 후리소소이다바라보고 있자니 쏟아져 내렸어息も生き辛さも忘れて이키모 이키 츠라사모 와스레테숨도 삶의 어려움도 잊고溶け込めたら楽なのにな토케코메타라 라쿠나노니나녹아들 수 있다면 편할 텐데やらず雨と歌って야라즈 아메토 우탓테떠나지 못하게 하는 비와 함께 노래하며また笑うこと諦めていたんだ마타 와라우 코토 아키라메테이타다다시 웃는 것을 포기하고 있었어踏み出してみればそこまで高くはないみたいだ후미다시테미레바 소코마데 타카쿠와 나이미타이다발을 내디뎌 보니 그렇게까지 높지는 않은 것 같아誓いもこれくらいなら치카이모 코레쿠라이나라맹세도 이 정도라면怖がったことが僕を確かにここに繋いだ코와갓타 코토가 보쿠오 타시카니 코코니 츠나이다두려워했던 것이 나를 확실히 여기에 묶어 놓았어不甲斐ない雲후가이나이 쿠모무력한 구름手触りはなくて테자와리와 나쿠테촉감도 없어溜め込んでたことは忘れた타메콘데타 코토와 와스레타쌓아두었던 것들을 잊었어途方に暮れた風は今に凪ぐ토호오니 쿠레타 카제와 이마니 나구갈 곳을 잃은 바람도 이제 곧 잔잔해질 거야苦しめられたはずのあの景色も今じゃ愛しくて쿠루시메라레타 하즈노 아노케시키모 이마자 이토시쿠테괴로움을 겪었던 그 풍경도 지금은 사랑스러워서立ち尽くすだけでも타치츠쿠스다케데모그저 서 있는 것만으로도踏み出せたからもう構わないんだ후미다세타카라 모오 카마와나이다한 걸음 내디뎠으니 이제 괜찮아誓いも破り捨てて치카이모 야부리스테테맹세도 버리고広がった目の前ほら確かにそこに見たんだ히로갓타 메노 마에 호라 타시카니 소코니 미타다눈앞에 펼쳐진 광경을 봐, 분명히 거기서 보았어白んだ空시란다 소라하얗게 밝아오는 하늘大人に近づくたび오토나니 치카즈쿠 타비어른이 되어갈수록自分が嫌になって지분가 이야니 낫테자신이 싫어져서ぼやけたままの景色も塗り替えて보야케타 마마노 케시키모 누리카에테흐릿한 채인 풍경도 다시 그려나가자いつか乾いて砕けぬように이츠카 카와이테 쿠다케누요오니언젠가 말라 부서지지 않도록そっと濡らしながら솟토 누라시나가라살며시 적시면서それだけは確か소레다케와 타시카그것만은 확실해音まで不確か오토마데 후타시카소리마저 불확실해" }, { "title": "s3를 이용하여 단축 Url 서비스 만들기", "url": "/posts/url-shortener/", "categories": "dev, project", "tags": "dev, project", "date": "2022-01-26 09:56:00 +0900", "snippet": "만들게 된 이유필자는 코드 공유시 tio.run 라는 사이트를 주로 사용한다.지원하는 언어의 수도 많고 디자인도 심플해서 자주 사용하는데 공유 기능을 사용할때 문제가 생겼다.공유시 주소에 인코딩한 코드를 넣는 방식이라 주소가 너무 길어진다는것이다.이런 문제 해결을 위해서 url 단축기를 만들기로 했다.url 단축 방식url 단축기를 만든다고하면 db에 단축주소와 연결주소를 저장하고 단축 주소 접속시 리다이렉트 하는 방식을 생각 할 것이다.하지만 이런 방법은 db 를 사용하기 때문에 신경쓸 부분이 많아진다.그래서 찾은 방식이 이것이다.s3에 저장되는 파일은 다양한 메타데이터를 가지고 있다.그중에 Website Redirect Location은 해당 파일 접근시 리다이렉트 하는 기능을 가지고 있다.이것을 이용해서 만들어보자.aws 설정먼저 s3에 버킷을 만든다.필자는 short.hotkey.sh 이라는 이름으로 버킷을 만들었다.여기서 바로 파일을 만들고 메타데이터를 설정해도 상관은 없지만 s3에서 주는 주소는 너무 길어 짧은 주소라고 보기 힘들다.그래서 다음으로는 CloudFront를 이용해서 도메인을 버킷이랑 연결했다.연결하는 방법은 아래 주소를 잠고하면 된다.[AWS] CloudFront와 S3 연결하기이러면 aws 에서 준비는 끝이다.단축 서버 만들기그러면 이제 위에서 만든 s3를 이용하는 서버를 만들어보자.필자는 aws lambda에서 ts를 이용하여 만들었다.처음으로 파일명에 사용하기 위한 랜덤 문자열을 만드는 함수부터 만들었다.private static input = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;;public static GetRandomString(length: number) { let result = &quot;&quot;; let charactersLength = RandomGenerator.input.length; for (let i = 0; i &amp;lt; length; i++) { result += RandomGenerator.input.charAt( Math.floor(Math.random() * charactersLength) ); } return result;}다음으로 s3에 접근하는 부분을 싱글톤을 이용해서 만들었다.public static get S3(): AWS.S3 { if (this.s3 === null) { this.s3 = new AWS.S3({ apiVersion: &quot;2006-03-01&quot; }); } return this.s3;}private static s3: AWS.S3 = null;파일명은 날짜 + 랜덤 문자열을 이용하여 만든다.let fileKey = &quot;&quot;;try { while (1) { fileKey = `${dayjs().date()}/${RandomGenerator.GetRandomString( 8 )}`; await Define.S3.headObject({ Bucket: Define.BucketName, Key: fileKey, }).promise(); }} catch {}중복 파일명이 있는지 확인하기 위해 headObject를 사용했다.headObject는 해당 파일이 없을시 objectNotExists 오류를 반환한다.이걸 이용하여 try catch 와 while로 중복되는 파일명이 없을때까지 반복한다.이후 만든 파일 이름을 이용해서 WebsiteRedirectLocation 값으로 리다이렉트할 주소를 넣어서 저장하면 된다.await Define.S3.putObject({ Bucket: Define.BucketName, Key: fileKey, ACL: &quot;public-read&quot;, Body: Buffer.from([]), ContentType: &quot;text/html&quot;, WebsiteRedirectLocation: data.urlData,}).promise();마지막으로 만든 파일명을 반환하면 끝이다.const response = { headers: { &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;, &quot;Access-Control-Allow-Credentials&quot;: true, }, statusCode: 200, body: JSON.stringify({ url: `https://s.hotkey.sh/${fileKey}`, }),};callback(undefined, response);return;코드 전문 export default class RandomGenerator { private static input = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;; public static GetRandomString(length: number) { let result = &quot;&quot;; let charactersLength = RandomGenerator.input.length; for (let i = 0; i &amp;lt; length; i++) { result += RandomGenerator.input.charAt( Math.floor(Math.random() * charactersLength) ); } return result; }} export default class Define { public static BucketName: string = &quot;short.hotkey.sh&quot;; // ===============================S3================================ public static get S3(): AWS.S3 { if (this.s3 === null) { this.s3 = new AWS.S3({ apiVersion: &quot;2006-03-01&quot; }); } return this.s3; } private static s3: AWS.S3 = null; // ================================================================= public static region = &quot;ap-northeast-2&quot;;} import { Handler, Context, Callback } from &quot;aws-lambda&quot;;import dayjs from &quot;dayjs&quot;;import Define from &quot;./Define&quot;;import RandomGenerator from &quot;./Function/RandomGenerator&quot;;export const handler: Handler = async ( event: any, context: Context, callback: Callback) =&amp;gt; { const data = new HasuraInputData().LoadFromJsonString(event.body); console.log(event.body); let fileKey = &quot;&quot;; try { while (1) { fileKey = `${dayjs().date()}/${RandomGenerator.GetRandomString( 8 )}`; await Define.S3.headObject({ Bucket: Define.BucketName, Key: fileKey, }).promise(); } } catch {} await Define.S3.putObject({ Bucket: Define.BucketName, Key: fileKey, ACL: &quot;public-read&quot;, Body: Buffer.from([]), ContentType: &quot;text/html&quot;, WebsiteRedirectLocation: data.urlData, }).promise(); const response = { headers: { &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;, &quot;Access-Control-Allow-Credentials&quot;: true, }, statusCode: 200, body: JSON.stringify({ url: `https://s.hotkey.sh/${fileKey}`, }), }; callback(undefined, response); return;};class HasuraInputData { public urlData: string; public LoadFromJsonString(jsonString: string): HasuraInputData { return this.LoadFromJson(JSON.parse(jsonString)); } public LoadFromJson(jsonData: any): HasuraInputData { this.urlData = jsonData.input.url_data as string; return this; }} 프론트 만들기프론트는 next.js 를 사용하여 간단하게 만들었다.프론트부분은 특별한 설명이 필요없을 정도로 간단하게 위에서 만든 서버에 요청을 보내고결과값을 보여주는게 끝이다.완성한 결과물완성한 결과물이다.단축할 주소를 입력하고 만들기 버튼을 누르면 짧은 주소가 나온다https://hotkey.sh/short참고한 자료https://aws.amazon.com/ko/blogs/compute/build-a-serverless-private-url-shortener/https://stackoverflow.com/questions/36830462/shorten-s3-signed-url" }, { "title": "winforms 에서 부드러운 둥근 모서리 만들기", "url": "/posts/smooth-rounded-corners-in-winform/", "categories": "dev, stackoverflow", "tags": "dev, stackoverflow, csharp, winforms", "date": "2022-01-01 10:27:00 +0900", "snippet": "해당 글 주소creating-smooth-rounded-corners-in-winform-applications/윈폼에서 둥근 테두리에 관하여 검색하면 대부분의 결과가 CreateRoundRectRgn 를 이용한 방법이다.하지만 CreateRoundRectRgn 를 이용하면 완벽하게 둥근 테두리가 아닌 눈으로 볼때 약간 어색할 수 있는 테두리가 나온다.이것을 더욱 선명하고 부드럽게 만들어 보자 일단 Win32api 를 이용하지 않고 둥근 사각형을 그려보자.해당코드는 여기를 참조하여 만들었다2가지 메서드를 추가하고public static GraphicsPath RoundedRect(Rectangle bounds, int radius){ int diameter = radius * 2; Size size = new Size(diameter, diameter); Rectangle arc = new Rectangle(bounds.Location, size); GraphicsPath path = new GraphicsPath(); if (radius == 0) { path.AddRectangle(bounds); return path; } // top left arc path.AddArc(arc, 180, 90); // top right arc arc.X = bounds.Right - diameter; path.AddArc(arc, 270, 90); // bottom right arc arc.Y = bounds.Bottom - diameter; path.AddArc(arc, 0, 90); // bottom left arc arc.X = bounds.Left; path.AddArc(arc, 90, 90); path.CloseFigure(); return path;}public static void FillRoundedRectangle(Graphics graphics, Brush brush, Rectangle bounds, int cornerRadius){ if (graphics == null) throw new ArgumentNullException(&quot;graphics&quot;); if (brush == null) throw new ArgumentNullException(&quot;brush&quot;); using (GraphicsPath path = RoundedRect(bounds, cornerRadius)) { graphics.FillPath(brush, path); }}부드러운 효과를 주기 안티 앨리어싱을 사용한다.이를 위해 graphics.SmoothingMode로 SmoothingMode.HighQuality 를 이용한다.안티 앨리어싱과 관련한 글은 여기서 볼수 있다.private void Form1_Paint(object sender, PaintEventArgs e){ Graphics graphics = e.Graphics; Rectangle gradientRectangle = new Rectangle(0, 0, this.Width - 1, this.Height - 1); Brush b = new LinearGradientBrush(gradientRectangle, Color.DarkSlateBlue, Color.MediumPurple, 0.0f); graphics.SmoothingMode = SmoothingMode.HighQuality; FillRoundedRectangle(graphics, b, gradientRectangle, 35);}여기까지 끝나면 위의 방식보다 둥근 사각형을 얻을 수 있다.그러면 이제 꼭짓점 부분을 투명하게 만들어 보자.해당 코드는 여기를 참고하여 만들었다.우리는 꼭짓점 부분을 투명하게 만들기 위하여 Per Pixel Alpha Blend를 이용할 것 이다.public void SetBitmap(Bitmap bitmap){ SetBitmap(bitmap, 255);}public void SetBitmap(Bitmap bitmap, byte opacity){ if (bitmap.PixelFormat != PixelFormat.Format32bppArgb) throw new ApplicationException(&quot;The bitmap must be 32ppp with alpha-channel.&quot;); IntPtr screenDc = Win32.GetDC(IntPtr.Zero); IntPtr memDc = Win32.CreateCompatibleDC(screenDc); IntPtr hBitmap = IntPtr.Zero; IntPtr oldBitmap = IntPtr.Zero; try { hBitmap = bitmap.GetHbitmap(Color.FromArgb(0)); oldBitmap = Win32.SelectObject(memDc, hBitmap); Win32.Size size = new Win32.Size(bitmap.Width, bitmap.Height); Win32.Point pointSource = new Win32.Point(0, 0); Win32.Point topPos = new Win32.Point(Left, Top); Win32.BLENDFUNCTION blend = new Win32.BLENDFUNCTION(); blend.BlendOp = Win32.AC_SRC_OVER; blend.BlendFlags = 0; blend.SourceConstantAlpha = opacity; blend.AlphaFormat = Win32.AC_SRC_ALPHA; Win32.UpdateLayeredWindow(Handle, screenDc, ref topPos, ref size, memDc, ref pointSource, 0, ref blend, Win32.ULW_ALPHA); } finally { Win32.ReleaseDC(IntPtr.Zero, screenDc); if (hBitmap != IntPtr.Zero) { Win32.SelectObject(memDc, oldBitmap); Win32.DeleteObject(hBitmap); } Win32.DeleteDC(memDc); }}protected override CreateParams CreateParams{ get { CreateParams cp = base.CreateParams; cp.ExStyle |= 0x00080000; return cp; }}위에 있는 메서드를 추가하고 Form Load 부분에 해당 코드를 추가한다.private void Form1_Load(object sender, EventArgs e){ Bitmap myBitmap = new Bitmap(this.Width, this.Height); Graphics graphics = Graphics.FromImage(myBitmap); Rectangle gradientRectangle = new Rectangle(0, 0, this.Width - 1, this.Height - 1); Brush b = new LinearGradientBrush(gradientRectangle, Color.DarkSlateBlue, Color.MediumPurple, 0.0f); graphics.SmoothingMode = SmoothingMode.HighQuality; FillRoundedRectangle(graphics, b, gradientRectangle, 35); SetBitmap(myBitmap);}해당코드는 폼 사이즈와 동일한 Bitmap을 만들고 그 위에 둥근 사각형을 그리는 것 이다.다 완성한것 같지만 여기서 폼을 투명하게 만들기 위하여 CreateParams.ExStyle 을 WS_EX_LAYERED(0x00080000) 으로 변경하였다.해당 글을 이용하여 적어보자면 UpdateLayeredWindow 를 사용하는 경우 응용 프로그램은 WM_PAINT 또는 기타 그림 메시지에 응답 할 필요가 없습니다. 이미 창에 대한 시각적 표현을 제공했으며 시스템에서 해당 이미지를 저장하고 구성하고 렌더링하는 작업을 처리하기 때문입니다. 화면. UpdateLayeredWindow 는 매우 강력하지만 종종 기존 Win32 응용 프로그램이 그리는 방식을 수정해야합니다.즉 해당 기능을 이용하면 폼 위에 있는 컨트롤이 자동적으로 그려지지 않는다는 것이다.그러면 컨트롤을 수동으로 그려보자.foreach (Control ctrl in this.Controls){ using (Bitmap bmp = new Bitmap(ctrl.Width, ctrl.Height)) { Rectangle rect = new Rectangle(0, 0, ctrl.Width, ctrl.Height); ctrl.DrawToBitmap(bmp, rect); graphics.DrawImage(bmp, ctrl.Location); }}해당 코드를 이용해서 컨트롤을 수동으로 그릴 수 있다.이를 연속적으로 그리기 위해서 Timer 를 이용해 보자.private Timer drawTimer = new Timer(); // 폼 로드후 그리기 위해서 생성자가 아닌 OnLoad 에서 초기화 한다.protected override void OnLoad(EventArgs e){ if (!DesignMode) { drawTimer.Interval = 1000 / 60; drawTimer.Tick += DrawForm; drawTimer.Start(); } base.OnLoad(e);}private void DrawForm(object pSender, EventArgs pE){ using (Bitmap backImage = new Bitmap(this.Width, this.Height)) { using (Graphics graphics = Graphics.FromImage(backImage)) { Rectangle gradientRectangle = new Rectangle(0, 0, this.Width - 1, this.Height - 1); using (Brush b = new LinearGradientBrush(gradientRectangle, Color.DarkSlateBlue, Color.MediumPurple, 0.0f)) { graphics.SmoothingMode = SmoothingMode.HighQuality; RoundedRectangle.FillRoundedRectangle(graphics, b, gradientRectangle, 35); foreach (Control ctrl in this.Controls) { using (Bitmap bmp = new Bitmap(ctrl.Width, ctrl.Height)) { Rectangle rect = new Rectangle(0, 0, ctrl.Width, ctrl.Height); ctrl.DrawToBitmap(bmp, rect); graphics.DrawImage(bmp, ctrl.Location); } } PerPixelAlphaBlend.SetBitmap(backImage, Left, Top, Handle); } } }}이를 바탕으로 만든 폼 코드이다.코드 접기/펼치기 버튼 public class HotkeyRoundedForm : Form{ private Timer drawTimer = new Timer(); public HotkeyRoundedForm() { this.FormBorderStyle = FormBorderStyle.None; } protected override void OnLoad(EventArgs e) { if (!DesignMode) { drawTimer.Interval = 1000 / 60; drawTimer.Tick += DrawForm; drawTimer.Start(); } base.OnLoad(e); } private void DrawForm(object pSender, EventArgs pE) { using (Bitmap backImage = new Bitmap(this.Width, this.Height)) { using (Graphics graphics = Graphics.FromImage(backImage)) { Rectangle gradientRectangle = new Rectangle(0, 0, this.Width - 1, this.Height - 1); using (Brush b = new LinearGradientBrush(gradientRectangle, Color.DarkSlateBlue, Color.MediumPurple, 0.0f)) { graphics.SmoothingMode = SmoothingMode.HighQuality; RoundedRectangle.FillRoundedRectangle(graphics, b, gradientRectangle, 35); foreach (Control ctrl in this.Controls) { using (Bitmap bmp = new Bitmap(ctrl.Width, ctrl.Height)) { Rectangle rect = new Rectangle(0, 0, ctrl.Width, ctrl.Height); ctrl.DrawToBitmap(bmp, rect); graphics.DrawImage(bmp, ctrl.Location); } } PerPixelAlphaBlend.SetBitmap(backImage, Left, Top, Handle); } } } } protected override void OnPaint(PaintEventArgs e) { if (DesignMode) { Graphics graphics = e.Graphics; Rectangle gradientRectangle = new Rectangle(0, 0, this.Width - 1, this.Height - 1); Brush b = new LinearGradientBrush(gradientRectangle, Color.DarkSlateBlue, Color.MediumPurple, 0.0f); graphics.SmoothingMode = SmoothingMode.HighQuality; RoundedRectangle.FillRoundedRectangle(graphics, b, gradientRectangle, 35); } base.OnPaint(e); } protected override CreateParams CreateParams { get { CreateParams cp = base.CreateParams; if (!DesignMode) { cp.ExStyle |= 0x00080000; } return cp; } }}public static class RoundedRectangle{ public static GraphicsPath RoundedRect(Rectangle bounds, int radius) { int diameter = radius * 2; Size size = new Size(diameter, diameter); Rectangle arc = new Rectangle(bounds.Location, size); GraphicsPath path = new GraphicsPath(); if (radius == 0) { path.AddRectangle(bounds); return path; } // top left arc path.AddArc(arc, 180, 90); // top right arc arc.X = bounds.Right - diameter; path.AddArc(arc, 270, 90); // bottom right arc arc.Y = bounds.Bottom - diameter; path.AddArc(arc, 0, 90); // bottom left arc arc.X = bounds.Left; path.AddArc(arc, 90, 90); path.CloseFigure(); return path; } public static void FillRoundedRectangle(Graphics graphics, Brush brush, Rectangle bounds, int cornerRadius) { if (graphics == null) throw new ArgumentNullException(&quot;graphics&quot;); if (brush == null) throw new ArgumentNullException(&quot;brush&quot;); using (GraphicsPath path = RoundedRect(bounds, cornerRadius)) { graphics.FillPath(brush, path); } }}internal static class PerPixelAlphaBlend{ public static void SetBitmap(Bitmap bitmap, int left, int top, IntPtr handle) { SetBitmap(bitmap, 255, left, top, handle); } public static void SetBitmap(Bitmap bitmap, byte opacity, int left, int top, IntPtr handle) { if (bitmap.PixelFormat != PixelFormat.Format32bppArgb) throw new ApplicationException(&quot;The bitmap must be 32ppp with alpha-channel.&quot;); IntPtr screenDc = Win32.GetDC(IntPtr.Zero); IntPtr memDc = Win32.CreateCompatibleDC(screenDc); IntPtr hBitmap = IntPtr.Zero; IntPtr oldBitmap = IntPtr.Zero; try { hBitmap = bitmap.GetHbitmap(Color.FromArgb(0)); oldBitmap = Win32.SelectObject(memDc, hBitmap); Win32.Size size = new Win32.Size(bitmap.Width, bitmap.Height); Win32.Point pointSource = new Win32.Point(0, 0); Win32.Point topPos = new Win32.Point(left, top); Win32.BLENDFUNCTION blend = new Win32.BLENDFUNCTION(); blend.BlendOp = Win32.AC_SRC_OVER; blend.BlendFlags = 0; blend.SourceConstantAlpha = opacity; blend.AlphaFormat = Win32.AC_SRC_ALPHA; Win32.UpdateLayeredWindow(handle, screenDc, ref topPos, ref size, memDc, ref pointSource, 0, ref blend, Win32.ULW_ALPHA); } finally { Win32.ReleaseDC(IntPtr.Zero, screenDc); if (hBitmap != IntPtr.Zero) { Win32.SelectObject(memDc, oldBitmap); Win32.DeleteObject(hBitmap); } Win32.DeleteDC(memDc); } }}internal class Win32{ public enum Bool { False = 0, True }; [StructLayout(LayoutKind.Sequential)] public struct Point { public Int32 x; public Int32 y; public Point(Int32 x, Int32 y) { this.x = x; this.y = y; } } [StructLayout(LayoutKind.Sequential)] public struct Size { public Int32 cx; public Int32 cy; public Size(Int32 cx, Int32 cy) { this.cx = cx; this.cy = cy; } } [StructLayout(LayoutKind.Sequential, Pack = 1)] struct ARGB { public byte Blue; public byte Green; public byte Red; public byte Alpha; } [StructLayout(LayoutKind.Sequential, Pack = 1)] public struct BLENDFUNCTION { public byte BlendOp; public byte BlendFlags; public byte SourceConstantAlpha; public byte AlphaFormat; } public const Int32 ULW_COLORKEY = 0x00000001; public const Int32 ULW_ALPHA = 0x00000002; public const Int32 ULW_OPAQUE = 0x00000004; public const byte AC_SRC_OVER = 0x00; public const byte AC_SRC_ALPHA = 0x01; [DllImport(&quot;user32.dll&quot;, ExactSpelling = true, SetLastError = true)] public static extern Bool UpdateLayeredWindow(IntPtr hwnd, IntPtr hdcDst, ref Point pptDst, ref Size psize, IntPtr hdcSrc, ref Point pprSrc, Int32 crKey, ref BLENDFUNCTION pblend, Int32 dwFlags); [DllImport(&quot;user32.dll&quot;, ExactSpelling = true, SetLastError = true)] public static extern IntPtr GetDC(IntPtr hWnd); [DllImport(&quot;user32.dll&quot;, ExactSpelling = true)] public static extern int ReleaseDC(IntPtr hWnd, IntPtr hDC); [DllImport(&quot;gdi32.dll&quot;, ExactSpelling = true, SetLastError = true)] public static extern IntPtr CreateCompatibleDC(IntPtr hDC); [DllImport(&quot;gdi32.dll&quot;, ExactSpelling = true, SetLastError = true)] public static extern Bool DeleteDC(IntPtr hdc); [DllImport(&quot;gdi32.dll&quot;, ExactSpelling = true)] public static extern IntPtr SelectObject(IntPtr hDC, IntPtr hObject); [DllImport(&quot;gdi32.dll&quot;, ExactSpelling = true, SetLastError = true)] public static extern Bool DeleteObject(IntPtr hObject);} 위의 코드를 넣고 public partial class Form1 : HotkeyRoundedForm 이런식으로HotkeyRoundedForm 을 상속받아 사용하면 된다." } ]
